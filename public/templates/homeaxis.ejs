<%  if (!preview) { -%>
; <%- filename %>
; called to home the <%- axisLetter %> axis
;
; generated by RepRapFirmware Configuration Tool v<%- version %> on <%- (new Date()).toString() %>
<%  } -%>

<%  // Get Z-probe values
    const zProbe = model.sensors.probes.find(probe => probe !== null);
    const diveHeight = zProbe ? zProbe.diveHeight : 5;
    const travelSpeed = zProbe ? zProbe.travelSpeed : 6000;

    // Get endstop
    const endstop = (axisIndex >= 0 && axisIndex < model.sensors.endstops.length) ? model.sensors.endstops[axisIndex] : null;
    const firstDriver = (axis.drivers.length > 0) ? model.configTool.drivers.find(driver => driver.id.equals(axis.drivers[0])) : null;
    const fastHomingSpeed = (firstDriver && firstDriver.homingSpeeds.length > 0) ? firstDriver.homingSpeeds[0] * 60 : 600;
    const slowHomingSpeed = (firstDriver && firstDriver.homingSpeeds.length > 1) ? firstDriver.homingSpeeds[1] * 60 : 300;

    // Lift Z only if Z isn't being homed
    if (axisLetter !== 'Z' || endstop.type === EndstopType.ZProbeAsEndstop) { -%>
G1 H2 Z<%- diveHeight %> ; lift Z
<%  }

    // Check how the axis is supposed to be homed
    if (endstop) {
        if (endstop.type === EndstopType.ZProbeAsEndstop && axisLetter === 'Z') {
            // Home Z using Z-probe
            let xCenter, yCenter;
            if (model.move.compensation.probeGrid !== null && model.move.compensation.probeGrid.axes[0] === 'X' && model.move.compensation.probeGrid.axes[1] === 'Y') {
                xCenter = model.move.compensation.probeGrid.mins[0] + (model.move.compensation.probeGrid.maxs[0] - model.move.compensation.probeGrid.mins[0]) / 2 - zProbe.offsets[0];
                yCenter = model.move.compensation.probeGrid.mins[1] + (model.move.compensation.probeGrid.maxs[1] - model.move.compensation.probeGrid.mins[1]) / 2 - zProbe.offsets[1];
                if (preview) { -%>
; NOTE: The following XY position is determined from the probe grid defined in the next section
<%              }
            } else {
                xCenter = model.move.axes[0].min + (model.move.axes[0].max - model.move.axes[0].min) / 2 - zProbe.offsets[0];
                yCenter = model.move.axes[1].min + (model.move.axes[1].max - model.move.axes[1].min) / 2 - zProbe.offsets[1];
            } -%>
G1 <%- params({
    X: xCenter,
    Y: yCenter,
    F: travelSpeed
}) %> ; go to bed centre
G30 ; probe the bed
<%      } else {
            // Home cartesian axis
-%>
G1 <%- params({
    H: 1,
    [axisLetter]: endstop.highEnd ? `{move.axes[${axisIndex}].max-move.axes[${axisIndex}].min+5}` : `{-(move.axes[${axisIndex}].max-move.axes[${axisIndex}].min+5)}`,
    F: fastHomingSpeed
}) %> ; move in the <%- (endstop.highEnd ? "+" : "-") + axisLetter %> direction, stopping if the homing switch is triggered<%- (fastHomingSpeed !== slowHomingSpeed) ? " (first pass)" : "" %>
<%          if (fastHomingSpeed !== slowHomingSpeed) {
                // second pass
-%>
G1 <%- params({
    H: 2,
    [axisLetter]: endstop.highEnd ? -5 : 5,
    F: travelSpeed
}) %> ; move back 5mm
G1 <%- params({
    H: 1,
    [axisLetter]: endstop.highEnd ? 10 : -10,
    F: slowHomingSpeed
}) %> ; move in the <%- (endstop.highEnd ? "+" : "-") + axisLetter %> direction, stopping if the homing switch is triggered (second pass)
<%          }
        }
    } else {
        // Home manually using message box
-%>
M291 S2 P"Please move the <%- axisLetter %> axis to the zero position and press OK" R"Homing axes" Y1 ; home <%- axisLetter %> manually
G92 <%- axisLetter %>{model.move.axes[<%- axisIndex %>].min} ; set <%- axisLetter %> to its minimum
<%  }

    // Lift Z only if Z isn't being homed
    if (axisLetter !== 'Z') { -%>
G1 H2 Z<%- -diveHeight %> F<%- travelSpeed %> ; lower Z again
<%  } -%>